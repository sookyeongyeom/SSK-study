# 웹 기초

## 목차
1. 웹
2. 배포
3. HTTP
4. REST API
5. FE-BE 통신
6. 개발 과정
7. 깃을 이용한 협업
8. 더 공부하면 좋을 내용
9. 용어 정리

## 들어가기 전
모든 기초를 다루고 있지 않고, SSK 웹 개발 과정에 필요한 핵심 위주로 담았습니다.  
마지막 장에서 더 공부하면 좋을 내용을 안내해드립니다.

## 웹
### 웹의 기본적인 원리
브라우저가 요청하면, 서버는 응답합니다.  
브라우저는 서버로부터 전달받은 자료를 화면에 렌더링하여 사용자에게 보여줍니다.  

### 요청과 응답
어떻게 요청하고 응답할까요?  
HTTP 프로토콜을 사용합니다.
- 프로토콜

브라우저의 주소창에 http://www.ssk.com/index.html 를 입력했다고 생각해봅시다.  
브라우저는 내부적으로 다음과 같은 HTTP 메시지를 만듭니다.
```
GET/index.html HTTP/1.1
Host: www.ssk.com
```
이 메시지가 담긴 패킷을 HTTP 프로토콜을 이용하여 전송하면,  
DNS 서버를 통해 ssk.com이 가리키는 컴퓨터의 IP 주소를 알아내어 해당 주소로 찾아가게 됩니다.
- DNS
- IP
- 패킷

ssk.com에 패킷이 정상적으로 도착했다고 생각해봅시다.  
ssk.com에는 웹서버 프로그램이 깔려있습니다.  
이 프로그램은 해당 컴퓨터의 80포트로 요청이 들어왔을 때, 메시지를 해석한 후  
해당 컴퓨터의 특정 디렉토리에서 요청받은 파일을 찾아 그 내용을 응답 메시지에 담아 요청지로 전송해주는 일을 합니다.  
(이해를 돕기 위한 설명입니다. 디렉토리에서 찾지 않는 경우에 대한 설명은 뒤에서 하겠습니다.)
- 웹서버
- 포트

응답 메시지의 예시입니다.
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3212

<html>
  <body>...</body>
</html>
```

브라우저가 이 메시지를 받게 되면,  
헤더 부분을 떼어내고 바디 부분의 HTML을 해석하여 DOM와 CSSOM을 만들게 됩니다.  
이 것을 바탕으로 브라우저의 화면을 렌더링하여 사용자에게 보여주는 것입니다.
- DOM
- CSSOM

### URL/URI
흔히 웹페이지 주소를 URL이라고 부르는데요.  
Uniform Resource Locator의 약자로 쉽게 풀자면 '자원의 위치'입니다.  

위 예시에서 http://www.ssk.com/index.html 를 입력했을 때  
ssk.com 라는 컴퓨터의 특정 디렉토리에 저장된 index.html 이라는 파일을 가져온다는 것을 확인했는데요.  
이렇듯 자원의 위치를 가리켜 정보를 받아오므로 Locator라는 명칭이 붙은 것입니다.

대표적인 예시로 연세포탈의 메인 주소는 https://portal.yonsei.ac.kr/main/index.jsp 입니다.  
portal.yonsei.ac.kr이라는 컴퓨터의 특정 디렉토리에 위치한 main 디렉토리의 index.jsp 파일을 가져온다고 해석할 수 있습니다.  
(여기서 portal.yonsei.ac.kr은 yonsei.ac.kr의 서브도메인입니다.)  
- 서브도메인

그럼 URI는 뭘까요?  
Uniform Resource Identifier의 약자입니다.  
현대 웹에서는 자원의 위치를 지정해서 가져오는 형식이 아니라,  
식별자를 정해놓고 해당 주소로 접근했을 때 원하는 동작을 수행하도록 만듭니다.  

말이 복잡한데요.  
예시를 들자면 이렇습니다.  

다음은 soo.com에서 서비스로 돌아가고 있는 server.py의 내용입니다.
```python
@app.route("/posts", methods=["GET"])
def send_post():
  ...
  return jsonify(posts)
```

http://www.soo.com/posts 경로로 접속했을 시 아래의 함수를 실행한다는 의미로 해석하시면 됩니다.  
파일 이름은 server.py인데, http://www.soo.com/server.py 로 접속한 것이 아니죠? 

이런 것도 가능합니다.
```python
@app.route("/posts", methods=["GET"])
def send_post():
  ...
  return jsonify(posts)
  
@app.route("/users", methods=["GET"])
def send_post():
  ...
  return jsonify(users)
```

이제 http://www.soo.com/posts 로 접속하면 posts 정보를,  
http://www.soo.com/users 로 접속하면 users 정보를 요청지에 반환하게 됩니다.

이렇듯 URI는 특정 위치가 아닌 식별자를 지정하여 원하는 자원에 대한 CRUD를 수행할 수 있게 합니다.  
요즈음의 웹은 SPA로 만들어지기 때문에 URI를 사용하는 것이 필수적입니다.  
여기에 대해서는 뒤에서 알아보겠습니다.
- CRUD
- SPA

### 웹 구조
우리가 지금까지 살펴본 브라우저는 클라이언트고, 응답하는 컴퓨터는 서버라고 부릅니다.  
웹 구조를 간단히 도식화하면 다음과 같습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcC3m5U%2Fbtrl44m8JeS%2F5rM2sVoxu5CK49NlwmMMF1%2Fimg.png)

클라이언트는 서버에 요청을 보내고, 서버는 요청을 처리하기 위해 필요한 데이터를 DB에서 가져옵니다.  
그리고 응답을 완성해 클라이언트에 전달하게 됩니다.

이 때 클라이언트에서 서버에 요청을 보내기까지의 과정을 프론트라고 부르고,  
클라이언트로부터 받은 요청을 처리하고 클라이언트에 응답을 반환하는 과정을 백이라고 합니다.

### 웹의 역사
과거의 웹은 HTML만으로 이루어져 있었습니다.  
곧 디자인에 대한 요구가 생기기 시작했고 그 결과 CSS가 탄생했습니다.  
그러나 HTML과 CSS만으로는 사용자와 상호작용하는 것이 불가능했습니다.

HTML은 Hyper Text Markup Language의 약자인데,  
여기서 Hyper는 HyperLink를 떠올리시면 됩니다.  

초기의 웹은 그저 문서 간 링크를 통해 왔다갔다하는 것이 다였습니다.  
사용자와의 어떠한 상호작용도 불가능했습니다. (링크를 클릭하는 것 외에는...)

따라서 상호작용에 대한 요구가 생겼고 이 때 Javascript가 탄생했습니다.  
Javascript를 이용하면 버튼을 눌렀을 때 팝업창이 뜬다거나 폰트의 색깔이 변한다거나 하는 것을 구현할 수 있습니다.  
대표적으로 다크모드를 구현할 수 있겠네요!

그러나 이것으로도 부족했습니다.  

웹서버는 단순히 80포트를 열어놓고 주시하고 있다가 요청이 들어오면 요청된 파일을 찾아 전달하는 것 밖에는 할 수 없었습니다.  
즉 사용자별로 다른 내용을 보여줄 수가 없었다는 뜻입니다.  

![image](https://user-images.githubusercontent.com/98504939/175811965-085530c3-db57-41ec-ba76-301d0192cdbd.png)

오른쪽을 보시면, 현재 로그인되어있는 사용자의 정보가 떠있죠?  
기존의 웹서버만을 이용해 이런 것을 가능하게 하려면 모든 사용자별로 개별 페이지를 일일이 만들어 서버에 저장해두어야 했습니다.  
애초에 사이트 가입도 불가하지만요.

사용자가 웹에 원하는 내용을 저장하고, 계정을 만들어 가입하고, 로그인했을 때 해당 사용자만을 위한 내용을 보여주려면 어떻게 해야 할까요?

이와 같은 요구에서 등장한 것이 웹 애플리케이션 서버입니다.








## 배포

## HTTP

## REST API

## FE-BE 통신

## 개발 과정

## 깃을 이용한 협업

## 더 공부하면 좋을 내용

## 용어 정리
